export declare class Config {
    /** auto register class, when class not found. default: false */
    autoRegister?: boolean;
    /** constructor inject, MUST in TypeScript with emitDecoratorMetadata and use decorator with class, default: true */
    constructorInject?: boolean;
}
export declare const DefaultRegisterOption: RegisterOptions;
export interface RegisterOptions {
    /** default: true */
    singleton?: boolean;
    /** if data a class, auto new a instance.
     *  if data a function, auto run(lazy).
     *  default: true */
    autoNew?: boolean;
    /**
     * register in superclass, you can get use superclass with getSubClasses method.
     * This setting is not inherited.
     * default: false
     * */
    regInSuperClass?: boolean;
}
export declare type ClassType = new (...args: any[]) => any;
export declare type InterceptorType = () => void;
export declare type KeyType = Function | string;
export declare type RegKeyType = KeyType | undefined;
export declare type GetReturnType<T, ClsType> = T extends undefined ? (ClsType extends new (...args: any[]) => infer R ? R : any) : T;
export interface Store {
    inited: boolean;
    value: any;
    options: RegisterOptions;
    subClasses: Store[];
}
export declare class IocContext {
    private config;
    private static defaultInstance;
    private components;
    static readonly DefaultInstance: IocContext;
    constructor(config?: Config);
    remove(keyOrType: KeyType): boolean;
    clear(): void;
    get<T = undefined, KeyOrType = any>(keyOrType: KeyOrType): GetReturnType<T, KeyOrType>;
    has(keyOrType: KeyType): boolean;
    getSubClasses<T>(keyOrType: KeyType): T[];
    replace(keyOrType: KeyType, newData: any, options?: RegisterOptions, force?: boolean): void;
    append(keyOrType: KeyType, subData: any, options?: RegisterOptions): void;
    register(data: any, key?: RegKeyType, options?: RegisterOptions): void;
    inject(instance: any, notFoundHandler?: (globalType: string, typeCls?: any) => any): void;
    private appendData;
    private newStore;
    private canBeKey;
    private genValue;
    private returnValue;
}
