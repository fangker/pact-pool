"use strict";

function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var utils_1 = require("./utils");

var utils_2 = require("../utils");

var Config = function Config() {
  _classCallCheck(this, Config);

  /** auto register class, when class not found. default: false */
  this.autoRegister = false;
  /** constructor inject, MUST in TypeScript with emitDecoratorMetadata and use decorator with class, default: true */

  this.constructorInject = true; // onNotFound: (globalType: string) => any
  // onGetValue: (data: Store) => any
};

exports.Config = Config;
exports.DefaultRegisterOption = {
  singleton: true,
  autoNew: true,
  regInSuperClass: false
};

var IocContext =
/*#__PURE__*/
function () {
  function IocContext() {
    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Config();

    _classCallCheck(this, IocContext);

    this.config = config;
    this.components = new Map();
  }

  _createClass(IocContext, [{
    key: "remove",
    value: function remove(keyOrType) {
      return this.components.delete(utils_1.getGlobalType(keyOrType));
    }
  }, {
    key: "clear",
    value: function clear() {
      this.components.clear();
    }
  }, {
    key: "get",
    value: function get(keyOrType) {
      var key = utils_1.getGlobalType(keyOrType);

      if (this.components.has(key)) {
        return this.returnValue(this.components.get(key));
      } else if (this.config.autoRegister && utils_1.isClass(keyOrType)) {
        this.register(keyOrType);
        return this.get(keyOrType);
      } else {
        return;
      }
    }
  }, {
    key: "has",
    value: function has(keyOrType) {
      return this.components.has(utils_1.getGlobalType(keyOrType));
    }
  }, {
    key: "getSubClasses",
    value: function getSubClasses(keyOrType) {
      var _this = this;

      var data = this.components.get(utils_1.getGlobalType(keyOrType));
      if (!data) return;
      return data.subClasses.map(function (sc) {
        return _this.returnValue(sc);
      });
    }
  }, {
    key: "replace",
    value: function replace(keyOrType, newData, options) {
      var force = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      var key = utils_1.getGlobalType(keyOrType);
      var data = this.components.get(key);

      if (data) {
        data.inited = false;
        data.value = this.genValue(newData, options || data.options);
      } else if (force) {
        this.register(newData, keyOrType, options);
      } else {
        throw new Error("the key:[".concat(key, "] is not register."));
      }
    }
  }, {
    key: "append",
    value: function append(keyOrType, subData) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : exports.DefaultRegisterOption;

      if (!this.canBeKey(keyOrType)) {
        throw new Error('key require a string or a class.');
      }

      var store;

      if (utils_1.isClass(subData)) {
        this.register(subData, undefined, options);
        store = this.components.get(utils_1.getGlobalType(subData));
      } else {
        store = this.newStore(subData, options);
      }

      this.appendData(utils_1.getGlobalType(keyOrType), keyOrType, options, store);
    }
  }, {
    key: "register",
    value: function register(data, key) {
      var _this2 = this;

      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : exports.DefaultRegisterOption;

      if (key) {
        if (!this.canBeKey(key)) {
          throw new Error('key require a string or a class.');
        }
      } else {
        if (!this.canBeKey(data)) {
          throw new Error('when data is not a class or string, require a key.');
        }
      }

      var dataType = key && utils_1.getGlobalType(key) || data && utils_1.getGlobalType(data);

      if (this.components.has(dataType)) {
        throw new Error("the key:[".concat(dataType, "] is already register."));
      }

      options = Object.assign({}, exports.DefaultRegisterOption, options);
      var store = this.newStore(data, options);
      this.components.set(dataType, store);

      if (options.regInSuperClass) {
        if (!(data instanceof Function)) {
          throw new Error('if need regInSuperClass, data MUST be a class.');
        }

        var newOptions = Object.assign({}, options, {
          regInSuperClass: false
        });
        var superClasses = utils_1.getSuperClassInfo(data);
        superClasses.forEach(function (sc) {
          return _this2.appendData(sc.type, sc.class, newOptions, store);
        });
      }
    }
  }, {
    key: "inject",
    value: function inject(instance, notFoundHandler) {
      var _this3 = this;

      var iocSelf = this;
      var classType = instance.constructor.prototype;
      utils_1.getInjects(classType).forEach(function (inject) {
        var key = inject.key,
            typeCls = inject.typeCls,
            globalType = inject.globalType;

        switch (inject.type) {
          case 'inject':
            var data = _this3.get(typeCls);

            if (data === undefined) {
              if (notFoundHandler) {
                data = notFoundHandler(globalType, typeCls);
              }

              if (data === undefined) {
                utils_2.logger.warn('Notfound:' + globalType);
              }
            }

            Object.defineProperty(instance, key, {
              configurable: true,
              writable: true,
              value: data
            });
            break;

          case 'lazyInject':
            var always = inject.always,
                subClass = inject.subClass;
            var descriptor = Object.getOwnPropertyDescriptor(instance, key);
            var defaultValue = descriptor && descriptor.value;
            Object.defineProperty(instance, key, {
              configurable: true,
              get: function get() {
                var data = subClass ? iocSelf.getSubClasses(typeCls) : iocSelf.get(typeCls);

                if (data === undefined) {
                  if (notFoundHandler) {
                    data = notFoundHandler(globalType, typeCls);
                  }

                  if (data === undefined) {
                    utils_2.logger.warn("Notfound: ".concat(globalType, ", use defaultValue."));
                  }
                } else {
                  defaultValue = undefined;

                  if (!always) {
                    Object.defineProperty(this, key, {
                      configurable: true,
                      writable: true,
                      value: data
                    });
                  }
                }

                return data || defaultValue;
              },
              set: function set(value) {
                Object.defineProperty(this, key, {
                  configurable: true,
                  writable: true,
                  value: value
                });
              }
            });
            break;
        }
      });
    }
  }, {
    key: "appendData",
    value: function appendData(keyType, typeData, options, store) {
      var superClass = this.components.get(keyType);

      if (!superClass) {
        this.register(typeData, undefined, options);
        superClass = this.components.get(keyType);
      }

      superClass.subClasses.push(store);
    }
  }, {
    key: "newStore",
    value: function newStore(data, options) {
      return {
        inited: false,
        value: this.genValue(data, options),
        options: options,
        subClasses: []
      };
    }
  }, {
    key: "canBeKey",
    value: function canBeKey(obj) {
      return obj instanceof Function || typeof obj === 'string';
    }
  }, {
    key: "genValue",
    value: function genValue(data, options) {
      var _this4 = this;

      var dataIsFunction = data instanceof Function;
      var dataIsClass = dataIsFunction && utils_1.isClass(data);
      return function () {
        if (dataIsFunction && options.autoNew) {
          if (dataIsClass) {
            var args = [_this4];

            if (_this4.config.constructorInject && Reflect && Reflect.getMetadata) {
              var paramTypes = Reflect.getMetadata('design:paramtypes', data);

              if (paramTypes) {
                args = paramTypes.map(function (type) {
                  if (type === data || type === undefined || type === null || type === Number || type === Error || type === Object || type === String || type === Boolean || type === Array || type === Function) {
                    return null;
                  }

                  return _this4.get(type);
                });
              }
            }

            var value = _construct(data, _toConsumableArray(args));

            _this4.inject(value);

            return value;
          } else {
            return data(_this4);
          }
        } else {
          return data;
        }
      };
    }
  }, {
    key: "returnValue",
    value: function returnValue(data) {
      if (data.options.singleton) {
        return data.inited ? data.value : (data.inited = true, data.value = data.value(), data.value);
      } else {
        return data.value();
      }
    }
  }], [{
    key: "DefaultInstance",
    get: function get() {
      return this.defaultInstance || (this.defaultInstance = new IocContext(), this.defaultInstance);
    }
  }]);

  return IocContext;
}();

exports.IocContext = IocContext;