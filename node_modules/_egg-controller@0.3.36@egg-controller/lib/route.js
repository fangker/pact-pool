"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
require("reflect-metadata");
const co = require("co");
const utils_1 = require("power-di/utils");
const egg_aop_1 = require("egg-aop");
const util_1 = require("./util");
const param_1 = require("./param");
const controller_1 = require("./controller");
const const_1 = require("./transformer/const");
const paramValidate_1 = require("./middleware/paramValidate");
const auth_1 = require("./middleware/auth");
/** 路由注解 */
function route(url, data = {}) {
    if (typeof url === 'string' || url instanceof RegExp) {
        data.url = url;
    }
    else if (url) {
        // url is metadata
        data = url;
    }
    return function (target, key) {
        const CtrlType = target.constructor;
        const typeGlobalName = utils_1.getGlobalType(CtrlType);
        const paramTypes = Reflect.getMetadata('design:paramtypes', target, key) || [];
        const schemas = data.schemas || {};
        /** from @ali/ts-metadata */
        const validateMetaInfo = [
            ...(Reflect.getMetadata('custom:validateRule', target, key) || data.validateMetaInfo || []),
        ].filter(info => {
            const valid = info.name && info.rule && info.rule.type;
            if (!valid) {
                console.log('[egg-controller] validate metaInfo in ', typeGlobalName, '->', key, ' is invalid:', info);
            }
            return valid;
        });
        /** from /lib/transformer */
        const requestSchema = Reflect.getMetadata(const_1.REQUEST_SCHEMA_KEY, target, key);
        const responseSchema = Reflect.getMetadata(const_1.RESPONSE_SCHEMA_KEY, target, key);
        const schemaDefinition = Reflect.getMetadata(const_1.SCHEMA_DEFINITION_KEY, target, key);
        const methodRules = param_1.getMethodRules(target, key);
        const typeInfo = Object.assign(Object.assign({ onError: function (_ctx, err) {
                throw err;
            } }, data), { typeGlobalName, typeClass: CtrlType, functionName: key, paramTypes: [], returnType: Reflect.getMetadata('design:returntype', target, key), schemas: {
                params: schemas.params || [],
                requestBody: schemas.requestBody || {},
                response: schemas.response || responseSchema || {},
                components: schemas.components || schemaDefinition || {},
            }, middleware: data.middleware || [], function: () => target[key] });
        /** complete params info */
        const paths = typeof typeInfo.url === 'string' && typeInfo.url.split('/');
        util_1.getParameterNames(target[key]).forEach((name, i) => {
            const config = methodRules.config[i] || {};
            const validateTypeIndex = validateMetaInfo.findIndex(v => v.name === name);
            typeInfo.paramTypes.push({
                name,
                type: paramTypes[i] === undefined ? Object : paramTypes[i],
                paramName: config.paramName || name,
                getter: methodRules.param[i],
                source: config.source ||
                    (paths && paths.some(p => p === `:${config.paramName || name}`) ? 'Param' : 'Any'),
                hidden: config.hidden,
                validateType: validateTypeIndex >= 0
                    ? validateMetaInfo.splice(validateTypeIndex, 1)[0].rule
                    : undefined,
                schema: util_1.getValue(() => typeInfo.schemas.params.find(p => p.name === name).schema) ||
                    util_1.getValue(() => typeInfo.schemas.requestBody.properties[name]) ||
                    util_1.getValue(() => requestSchema[name]),
            });
        });
        if (validateMetaInfo.length) {
            throw new Error(`[egg-controller] route: ${typeGlobalName}.${key} param validate defined error! no param use: ${JSON.stringify(validateMetaInfo)}`);
        }
        // add default middleware
        typeInfo.middleware.push(paramValidate_1.paramValidateMiddleware, auth_1.authMiddleware);
        typeInfo.function = function (ctx) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                // 'this' maybe is Controller or Context, in Chair.
                ctx = (this.request && this.response ? this : this.ctx) || ctx;
                const ctrl = egg_aop_1.getInstance(CtrlType, ctx.app, ctx);
                const args = yield param_1.getParamData(ctx, typeInfo);
                try {
                    let ret;
                    if (util_1.isGeneratorFunction(target[key])) {
                        ret = yield co(ctrl[key](...args));
                    }
                    else {
                        ret = yield Promise.resolve(ctrl[key](...args));
                    }
                    if (ret instanceof Error) {
                        if (ctx.app.env === 'local') {
                            throw new Error('请用 throw Error 替代 return Error');
                        }
                        else {
                            throw ret;
                        }
                    }
                    else if (ret !== undefined) {
                        ctx.body = ret;
                    }
                    const { ret404WhenNoChangeBody } = ctx.app.config.controller.compatible;
                    if (!ret404WhenNoChangeBody && ctx.body === undefined && ctx.status === 404) {
                        ctx.status = 204;
                    }
                    return ret;
                }
                catch (error) {
                    typeInfo.onError(ctx, error);
                }
            });
        };
        typeInfo.function.__name = key;
        controller_1.getControllerMetadata(CtrlType).routes.push(typeInfo);
    };
}
exports.route = route;
