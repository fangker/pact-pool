"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const co = require("co");
const egg_1 = require("egg");
const utils_1 = require("power-di/utils");
const util_1 = require("./util");
const route_1 = require("./route");
const CtrlMetaSymbol = Symbol('CtrlMetaSymbol');
const controllers = [];
/** 控制器列表 */
function getControllers(config) {
    controllers.filter(info => !info.init).forEach(info => initController(info.classType, config));
    return controllers;
}
exports.getControllers = getControllers;
/** 路由列表 */
function getRoutes(config) {
    return getControllers(config)
        .map(ctrl => ctrl.routes)
        .reduce((pv, cv) => pv.concat(cv), []);
}
exports.getRoutes = getRoutes;
/** global default middleware */
const defaultMiddleware = [];
function addDefaultMiddleware(middleware) {
    defaultMiddleware.push(...[].concat(middleware));
}
exports.addDefaultMiddleware = addDefaultMiddleware;
function getControllerMetadata(CtrlType) {
    const descriptor = Object.getOwnPropertyDescriptor(CtrlType, CtrlMetaSymbol);
    if (!descriptor) {
        const value = {
            classType: CtrlType,
            filePath: util_1.getCurrentLoadFilePath(),
            routes: [],
            middleware: [],
            init: false,
        };
        controllers.push(value);
        Object.defineProperty(CtrlType, CtrlMetaSymbol, {
            enumerable: false,
            configurable: false,
            value,
        });
        return getControllerMetadata(CtrlType);
    }
    return descriptor.value;
}
exports.getControllerMetadata = getControllerMetadata;
function controller(meta = {}) {
    return target => {
        const metadata = getControllerMetadata(target);
        Object.assign(metadata, meta);
    };
}
exports.controller = controller;
function initController(target, config) {
    const typeGlobalName = utils_1.getGlobalType(target);
    const metadata = getControllerMetadata(target);
    if (metadata.init) {
        return;
    }
    metadata.init = true;
    const prefix = metadata.prefix ||
        `/${typeGlobalName
            .split('_')[0]
            .toLowerCase()
            .replace('controller', '')}`;
    if (metadata.restful) {
        const restDefine = [
            { name: 'index', method: 'get', path: `${prefix}` },
            { name: 'new', method: 'get', path: `${prefix}/new` },
            { name: 'show', method: 'get', path: `${prefix}/:id` },
            { name: 'edit', method: 'get', path: `${prefix}/:id/edit` },
            { name: 'create', method: 'post', path: `${prefix}` },
            { name: 'update', method: 'put', path: `${prefix}/:id` },
            { name: 'destroy', method: 'delete', path: `${prefix}/:id` },
        ];
        restDefine.forEach(rest => {
            const func = target.prototype[rest.name];
            if (typeof func !== 'function') {
                return;
            }
            const routeInfo = metadata.routes.find(r => r.functionName === rest.name);
            if (routeInfo) {
                if (!routeInfo.method)
                    routeInfo.method = rest.method;
                if (!routeInfo.url)
                    routeInfo.url = rest.path;
            }
            else {
                route_1.route({
                    method: rest.method,
                    url: rest.path,
                })(target.prototype, rest.name, undefined);
            }
        });
    }
    metadata.routes.forEach(route => {
        route.middleware.unshift(...metadata.middleware);
        route.middleware.unshift(...defaultMiddleware);
        // catch the middleware error for onError
        route.middleware = route.middleware.map(mw => {
            return (app, typeInfo) => {
                const func = mw(app, typeInfo);
                return []
                    .concat(func)
                    .filter(s => s)
                    .map(item => {
                    return function (ctx, next) {
                        return tslib_1.__awaiter(this, void 0, void 0, function* () {
                            try {
                                if (util_1.isGeneratorFunction(item)) {
                                    return yield co(item.apply(this, [ctx, next]));
                                }
                                else {
                                    return yield item.apply(this, [ctx, next]);
                                }
                            }
                            catch (error) {
                                typeInfo.onError(ctx, error);
                            }
                        });
                    };
                });
            };
        });
        /** complete path & method info */
        const parsedPath = util_1.getNameAndMethod(route.functionName);
        if (!route.url) {
            route.url = `${prefix}/${parsedPath.name}`;
        }
        else if (typeof route.url === 'string') {
            const methodAndPath = route.url.split(/\s+/).map(s => s.trim());
            if (methodAndPath.length > 1 &&
                ['get', 'put', 'post', 'delete', 'patch'].indexOf(methodAndPath[0].toLowerCase()) >= 0) {
                route.method = [...new Set([].concat(methodAndPath[0] || []).concat(route.method || []))];
                route.url = methodAndPath[1];
            }
            if (!route.url.startsWith('/')) {
                route.url = `${prefix}/${route.url}`;
            }
        }
        if (!route.method) {
            route.method = parsedPath.method;
        }
        route.url = [].concat(route.url).map(url => {
            return typeof url === 'function' ? url(config) : url;
        });
        // parse params in path
        [].concat(route.url).forEach(url => {
            if (typeof url === 'string') {
                url.split('/').forEach(item => {
                    if (item.startsWith(':')) {
                        const paramName = item.substr(1);
                        const paramType = route.paramTypes.find(pt => pt.paramName === paramName);
                        if (paramType) {
                            paramType.source = 'Param';
                        }
                        else {
                            route.paramTypes.push({
                                name: paramName,
                                paramName: paramName,
                                type: String,
                                source: 'Param',
                                validateType: undefined,
                            });
                        }
                    }
                });
            }
        });
    });
}
class RESTfulController extends egg_1.Controller {
}
exports.RESTfulController = RESTfulController;
