"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ts = require("typescript");
const util_1 = require("../../util");
const getComment_1 = require("./getComment");
const isArrayType_1 = require("./isArrayType");
const getHashCode_1 = require("./getHashCode");
function getSchemaByType(type, config) {
    const { typeChecker } = config;
    // 接口层拆掉 Promise (Promise 对应 orm 中定义 lazy 情况)
    if (util_1.getValue(() => type.symbol.escapedName) === 'Promise') {
        type = type.typeArguments[0];
    }
    const defaultSchemaObject = {};
    const comment = getComment_1.getComment(type.type || type);
    if (comment) {
        defaultSchemaObject.description = comment;
    }
    const objectFlags = type.objectFlags;
    if (isArrayType_1.isArrayType(type)) {
        return Object.assign(Object.assign({}, defaultSchemaObject), { type: 'array', items: getSchemaByType(type.typeArguments[0], config) });
    }
    else if (type.flags & ts.TypeFlags.Boolean) {
        // boolean is kind of union
        return Object.assign(Object.assign({}, defaultSchemaObject), { type: 'boolean' });
    }
    else if (type.isUnion && type.isUnion()) {
        const unionType = type;
        if (unionType.types.every(t => !!(t.flags & ts.TypeFlags.EnumLiteral))) {
            return Object.assign(Object.assign({}, defaultSchemaObject), { type: 'string', enum: unionType.types.map((t) => {
                    return t.value;
                }) });
        }
        else {
            return Object.assign(Object.assign({}, defaultSchemaObject), { type: 'object', oneOf: unionType.types.map(t => getSchemaByType(t, config)) });
        }
    }
    else if (type.isIntersection && type.isIntersection()) {
        const intersectionType = type;
        return Object.assign(Object.assign({}, defaultSchemaObject), { type: 'object', allOf: intersectionType.types.map(t => getSchemaByType(t, config)) });
    }
    else if (type.isClassOrInterface()) {
        switch (type.symbol.escapedName) {
            case 'Date':
                return Object.assign(Object.assign({}, defaultSchemaObject), { type: 'string', format: 'date' });
            case 'Object':
                return Object.assign(Object.assign({}, defaultSchemaObject), { type: 'any' });
            default:
                return config.extendClass
                    ? extendClass(type, defaultSchemaObject, config)
                    : addRefTypeSchema(type, config);
        }
    }
    else if (objectFlags & ts.ObjectFlags.Anonymous) {
        return extendClass(type, defaultSchemaObject, config);
    }
    return Object.assign(Object.assign({}, defaultSchemaObject), { type: typeChecker.typeToString(type) });
}
exports.getSchemaByType = getSchemaByType;
function addRefTypeSchema(type, config) {
    const { schemaObjects, typeCache } = config;
    const cache = typeCache.find(c => c.type === type);
    if (cache) {
        return {
            $ref: `#/components/schemas/${cache.schemaName}`,
        };
    }
    const typeName = `${type.symbol.escapedName}`;
    let schemaName = typeName;
    if (schemaObjects[typeName]) {
        let i = 1;
        while (schemaObjects[`${typeName}_${i}`]) {
            i++;
        }
        schemaName = `${typeName}_${i}`;
    }
    const cacheData = { typeName, schemaName, type };
    typeCache.push(cacheData);
    const schema = getSchemaByType(type, Object.assign(Object.assign({}, config), { extendClass: true }));
    const hashCode = getHashCode_1.getHashCode(schema);
    const cacheIndex = typeCache.findIndex(c => c.hashCode === hashCode && c.typeName === typeName);
    if (cacheIndex >= 0) {
        typeCache.splice(typeCache.findIndex(c => c.schemaName === schemaName), 1);
        schemaName = cache.schemaName;
    }
    else {
        cacheData.hashCode = hashCode;
        schemaObjects[schemaName] = schema;
    }
    return {
        $ref: `#/components/schemas/${schemaName}`,
    };
}
function extendClass(type, defaultSchemaObject, config) {
    config = Object.assign(Object.assign({}, config), { extendClass: false });
    const schema = Object.assign(Object.assign({}, defaultSchemaObject), { type: 'object', properties: {}, required: [] });
    const indexType = type.getNumberIndexType() || type.getStringIndexType();
    if (indexType) {
        schema.additionalProperties = getSchemaByType(indexType, config);
    }
    type
        .getProperties()
        .filter(symbol => !symbol.valueDeclaration ||
        !symbol.valueDeclaration.modifiers ||
        !symbol.valueDeclaration.modifiers.some(m => {
            return [ts.SyntaxKind.PrivateKeyword, ts.SyntaxKind.ProtectedKeyword].includes(m.kind);
        }))
        .forEach(symbol => {
        const escapedName = `${symbol.escapedName}`;
        function setProp(value) {
            if (!util_1.getValue(() => symbol.valueDeclaration.questionToken)) {
                schema.required.push(escapedName);
            }
            schema.properties[escapedName] = Object.assign({ description: getComment_1.getComment(symbol) }, value);
        }
        if (symbol.valueDeclaration &&
            (ts.isMethodDeclaration(symbol.valueDeclaration) ||
                ts.isMethodSignature(symbol.valueDeclaration) ||
                ts.isArrowFunction(symbol.valueDeclaration))) {
            // 函数忽略
            return;
        }
        const targetType = util_1.getValue(() => symbol.type || symbol.target.type);
        if (targetType) {
            setProp(getSchemaByType(targetType, config));
        }
        else if (symbol.valueDeclaration) {
            const propType = config.typeChecker.getTypeAtLocation(symbol.valueDeclaration);
            if (util_1.getValue(() => propType.symbol.escapedName) === 'Function') {
                return;
            }
            // check arrow function prop.
            const arrowType = util_1.getValue(() => propType.symbol.valueDeclaration);
            if (arrowType && ts.isArrowFunction(arrowType)) {
                return;
            }
            setProp(getSchemaByType(propType, config));
        }
        else {
            setProp({
                type: 'any',
            });
        }
    });
    return schema;
}
