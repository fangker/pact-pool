"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ts = require("typescript");
const getSchemaByType_1 = require("../util/getSchemaByType");
const convert_1 = require("../util/convert");
const util_1 = require("../util");
const const_1 = require("../const");
const typescript_1 = require("typescript");
const METADATA = {};
console.log('[egg-controller] load transformer: response-schema.');
function transformer(program) {
    const typeChecker = program.getTypeChecker();
    return {
        before(ctx) {
            return (sourceFile) => {
                before(ctx, sourceFile, typeChecker);
                return util_1.walker(sourceFile, ctx);
            };
        },
        after(ctx) {
            return (sourceFile) => {
                after(ctx, sourceFile);
                return util_1.walker(sourceFile, ctx);
            };
        },
    };
}
exports.default = transformer;
function before(_, sourceFile, typeChecker) {
    // 当前编译文件需要保存的数据
    const fileData = (METADATA[sourceFile.fileName] = {
        // 方法定义
        methodDefine: {},
        schemaObjects: {},
        typeCache: [],
    });
    // 遍历文件中所有的 class
    sourceFile.statements
        .filter(n => ts.isClassDeclaration(n))
        .forEach(node => {
        node.forEachChild(cbNode => {
            if (util_1.isDecoratorNameInclude(cbNode, 'route')) {
                const clsMethod = util_1.getClsMethodKey(cbNode.parent.symbol.escapedName, cbNode.symbol.escapedName);
                const config = {
                    typeChecker,
                    schemaObjects: fileData.schemaObjects,
                    typeCache: fileData.typeCache,
                };
                const type = typeChecker.getTypeAtLocation(cbNode);
                const callSignatures = type.getCallSignatures()[0];
                // params parser
                const parameters = callSignatures.getParameters();
                const paramSchema = parameters.reduce((s, p) => {
                    const paramType = typeChecker.getTypeAtLocation(p.valueDeclaration);
                    s[`${p.escapedName}`] = getSchemaByType_1.getSchemaByType(paramType, config);
                    return s;
                }, {});
                // returnType parser
                const returnType = typeChecker.getReturnTypeOfSignature(callSignatures);
                let realType;
                if (util_1.getValue(() => returnType.symbol.escapedName) === 'Promise') {
                    realType = getSchemaByType_1.getSchemaByType(returnType.typeArguments[0], {
                        typeChecker,
                        schemaObjects: fileData.schemaObjects,
                        typeCache: fileData.typeCache,
                    });
                }
                else {
                    realType = getSchemaByType_1.getSchemaByType(returnType, config);
                }
                if (!fileData.methodDefine[clsMethod]) {
                    fileData.methodDefine[clsMethod] = {
                        paramSchema,
                        responseSchema: realType,
                    };
                }
            }
        });
    });
}
exports.before = before;
function after(_, sourceFile) {
    const fileData = METADATA[sourceFile.fileName];
    if (fileData) {
        sourceFile.statements.forEach(node => {
            if (ts.isExpressionStatement(node) && node.expression.arguments) {
                const className = util_1.getValue(() => node.expression.arguments[1].expression.escapedText);
                const methodName = util_1.getValue(() => node.expression.arguments[2].text);
                if (className && methodName) {
                    const methodSchema = util_1.getValue(() => fileData.methodDefine[util_1.getClsMethodKey(className, methodName)]);
                    if (methodSchema) {
                        const addData = [
                            ts.createCall(ts.setEmitFlags(ts.createIdentifier('__metadata'), typescript_1.EmitFlags.HelperName | typescript_1.EmitFlags.AdviseOnEmitNode), undefined, [ts.createLiteral(const_1.SCHEMA_DEFINITION_KEY), ts.createIdentifier('__SchemaDefinition')]),
                        ];
                        if (methodSchema.paramSchema) {
                            addData.unshift(ts.createCall(ts.setEmitFlags(ts.createIdentifier('__metadata'), typescript_1.EmitFlags.HelperName | typescript_1.EmitFlags.AdviseOnEmitNode), undefined, [ts.createLiteral(const_1.REQUEST_SCHEMA_KEY), convert_1.convert(methodSchema.paramSchema)]));
                        }
                        if (methodSchema.responseSchema) {
                            addData.unshift(ts.createCall(ts.setEmitFlags(ts.createIdentifier('__metadata'), typescript_1.EmitFlags.HelperName | typescript_1.EmitFlags.AdviseOnEmitNode), undefined, [ts.createLiteral(const_1.RESPONSE_SCHEMA_KEY), convert_1.convert(methodSchema.responseSchema)]));
                        }
                        node.expression.arguments[0].elements = node.expression.arguments[0].elements.concat(addData);
                    }
                }
            }
        });
        sourceFile.statements = ts.createNodeArray([
            ts.createVariableStatement([], ts.createVariableDeclarationList([
                ts.createVariableDeclaration('__SchemaDefinition', undefined, convert_1.convert(fileData.schemaObjects)),
            ], ts.NodeFlags.Const)),
            ...sourceFile.statements,
        ]);
    }
}
exports.after = after;
