"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const crypto = require("crypto");
const utils_1 = require("power-di/utils");
const util_1 = require("./util");
const error_1 = require("./error");
const extRules = {};
const getRuleKey = (target, key) => `${utils_1.getGlobalType(target.constructor)}_${key}`;
function getMethodRules(target, key) {
    const ruleKey = getRuleKey(target, key);
    if (!extRules[ruleKey]) {
        extRules[ruleKey] = {
            param: {},
            config: {},
        };
    }
    return extRules[ruleKey];
}
exports.getMethodRules = getMethodRules;
function FromCustom(custom, paramName, config) {
    return (target, key, index) => {
        const methodRule = getMethodRules(target, key);
        methodRule.param[index] = custom;
        methodRule.config[index] = Object.assign({ paramName }, config);
    };
}
exports.FromCustom = FromCustom;
function FromBody(paramName) {
    return FromCustom((ctx, name) => ctx.request.body[paramName || name], paramName, { source: 'Body' });
}
exports.FromBody = FromBody;
function FromParam(paramName) {
    return FromCustom((ctx, name) => ctx.params[paramName || name], paramName, { source: 'Param' });
}
exports.FromParam = FromParam;
function FromQuery(paramName) {
    return FromCustom((ctx, name) => ctx.query[paramName || name], paramName, { source: 'Query' });
}
exports.FromQuery = FromQuery;
function FromHeader(paramName) {
    return FromCustom((ctx, name) => ctx.request.header[paramName || name], paramName, { source: 'Header' });
}
exports.FromHeader = FromHeader;
function formatArg(argValue, validateType) {
    const type = util_1.getValue(() => validateType.type, 'any');
    // undefined 和 null 符合可空定义，是否可空由参数校验判断
    if (argValue === undefined || argValue === null) {
        return argValue;
    }
    // 类型转换
    switch (type) {
        case Number:
        case 'number':
            argValue = parseFloat(argValue);
            break;
        case 'int':
        case 'integer':
            argValue = parseInt(argValue);
            break;
        case Date:
        case 'date':
        case 'dateTime':
        case 'datetime':
            argValue = new Date(argValue);
        case Boolean:
        case 'boolean':
            if (argValue === true || argValue === 'true' || argValue === '1' || argValue === 1) {
                argValue = true;
            }
            else if (argValue === false || argValue === 'false' || argValue === '0' || argValue === 0) {
                argValue = false;
            }
            else {
                argValue = undefined;
            }
            break;
        case Object:
        case 'object':
        case undefined:
            try {
                argValue = JSON.parse(argValue);
            }
            catch (error) { }
            break;
        case Array:
        case 'array':
            const type = util_1.getValue(() => validateType.itemType) || 'any';
            argValue = argValue.map(arg => {
                return formatArg(arg, { type });
            });
            break;
        case String:
        case 'string':
            argValue = `${argValue}`;
            break;
        // TODO 自定义类型，new实例，或者属性赋值
    }
    return argValue;
}
function getArgs(ctx, typeInfo) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        let resData;
        if (typeInfo.encrypt) {
            const reqData = ctx.request.body && ctx.request.body['encrypt'];
            if (!reqData) {
                throw new error_1.BadRequestError('encrypt param error');
            }
            const config = ctx.app.config.controller.encrypt;
            const privateKeyType = config.type === 'PKCS8' ? 'PRIVATE KEY' : 'RSA PRIVATE KEY';
            resData = JSON.parse(crypto
                .privateDecrypt(util_1.formatKey(config.privateKey, privateKeyType), new Buffer(reqData))
                .toString());
        }
        else {
            resData = Object.assign(Object.assign(Object.assign(Object.assign({}, (ctx.request.body || {})), (ctx.queries || {})), (ctx.query || {})), (ctx.params || {}));
        }
        return yield Promise.all(typeInfo.paramTypes.map((p) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            const name = p.name;
            let argValue = undefined;
            // 获取参数值
            if (p.getter) {
                argValue = yield p.getter(ctx, name, p.type);
            }
            else {
                argValue = resData[name];
            }
            if (argValue === undefined) {
                return argValue;
            }
            return formatArg(argValue, util_1.getValue(() => p.validateType) || p);
        })));
    });
}
const ParamSymbol = Symbol('Params#EggARoute');
function getParamData(ctx, typeInfo) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        if (!Object.getOwnPropertyDescriptor(ctx, ParamSymbol) && typeInfo) {
            // lock, because `getArgs` is async function.
            Object.defineProperty(ctx, ParamSymbol, {
                enumerable: false,
                configurable: true,
                writable: true,
            });
            Object.defineProperty(ctx, ParamSymbol, {
                enumerable: false,
                configurable: false,
                writable: false,
                value: yield getArgs(ctx, typeInfo),
            });
        }
        return ctx[ParamSymbol];
    });
}
exports.getParamData = getParamData;
function getParamDataObj(ctx, typeInfo) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const paramData = yield getParamData(ctx, typeInfo);
        const paramObj = {};
        typeInfo.paramTypes.forEach((pt, i) => {
            paramObj[pt.name] = paramData[i];
        });
        return paramObj;
    });
}
exports.getParamDataObj = getParamDataObj;
