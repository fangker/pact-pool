"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const fs = require("fs");
const path = require("path");
const generatorFuncPrototype = Object.getPrototypeOf(function* () { });
function isGeneratorFunction(fn) {
    return typeof fn === 'function' && Object.getPrototypeOf(fn) === generatorFuncPrototype;
}
exports.isGeneratorFunction = isGeneratorFunction;
const asyncFuncPrototype = Object.getPrototypeOf(function () {
    return tslib_1.__awaiter(this, void 0, void 0, function* () { });
});
function isAsyncFunction(fn) {
    return typeof fn === 'function' && Object.getPrototypeOf(fn) === asyncFuncPrototype;
}
exports.isAsyncFunction = isAsyncFunction;
const methodPrefix = [
    { method: 'get', keys: ['get', 'find', 'query'] },
    { method: 'put', keys: ['put', 'modify', 'save', 'update', 'change'] },
    { method: 'post', keys: ['post', 'add', 'create'] },
    { method: 'delete', keys: ['delete', 'remove', 'destroy'] },
];
function getNameAndMethod(funcName) {
    let method = 'get', name = funcName;
    let tmpName = funcName.toLowerCase(), usePrefix = '';
    const prefix = methodPrefix.find(p => p.keys.some(k => {
        if (tmpName.startsWith(k)) {
            usePrefix = k;
            return true;
        }
        return false;
    }));
    if (prefix) {
        name = tmpName.substring(usePrefix.length) || funcName;
        method = prefix.method;
    }
    return { name, method };
}
exports.getNameAndMethod = getNameAndMethod;
const COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm;
const DEFAULT_PARAMS = /=[^,]*/gm;
const FAT_ARROWS = /=>.*$/gm;
function getParameterNames(fn) {
    if (!fn) {
        console.warn('NO fn for getParameterNames!');
        return [];
    }
    let code = typeof fn === 'function' ? fn.toString() : fn;
    let right = 0;
    for (let i = 0; i < code.length; i++) {
        const char = code[i];
        if (char === '(') {
            right++;
        }
        else if (char === ')') {
            right--;
            if (right === 0) {
                right = i;
                break;
            }
        }
    }
    code = code.substring(code.indexOf('(') + 1, right).replace(COMMENTS, '');
    const sub = code.match(/\(.*?\)/g);
    if (sub)
        sub.forEach(sub => (code = code.replace(sub, '')));
    return (code
        .replace(DEFAULT_PARAMS, '')
        .replace(FAT_ARROWS, '')
        .match(/([^\s,]+)/g) || []);
}
exports.getParameterNames = getParameterNames;
function getValue(func, defaultValue) {
    try {
        return func();
    }
    catch (error) {
        return defaultValue;
    }
}
exports.getValue = getValue;
function getFile(filePath) {
    const parsedPath = path.parse(filePath);
    if (parsedPath.ext === '.ts' && filePath.indexOf('.d.ts') < 0) {
        const jsPath = path.join(parsedPath.dir, `${parsedPath.name}.js`);
        if (fs.existsSync(jsPath)) {
            return jsPath;
        }
        else {
            return filePath;
        }
    }
    if (parsedPath.ext === '.js') {
        return filePath;
    }
}
function getDirFiles(dirPath) {
    const files = [];
    const dirStat = fs.statSync(dirPath);
    if (dirStat.isFile()) {
        const filePath = getFile(dirPath);
        filePath && files.push(filePath);
    }
    else if (dirStat.isDirectory()) {
        fs.readdirSync(dirPath).forEach(dirName => {
            const fullPath = path.join(dirPath, dirName);
            const stat = fs.statSync(fullPath);
            if (stat.isDirectory()) {
                files.push(...getDirFiles(fullPath));
            }
            else if (stat.isFile()) {
                const filePath = getFile(fullPath);
                filePath && files.push(filePath);
            }
        });
    }
    return Array.from(new Set(files));
}
exports.getDirFiles = getDirFiles;
/** work with loadDir/loadFile */
let currentLoadFilePath = undefined;
function loadDir(dirPath) {
    return getDirFiles(dirPath).forEach(filePath => loadFile(filePath));
}
exports.loadDir = loadDir;
function loadFile(filePath) {
    currentLoadFilePath = filePath;
    require(filePath);
    currentLoadFilePath = undefined;
}
exports.loadFile = loadFile;
function getCurrentLoadFilePath() {
    return currentLoadFilePath;
}
exports.getCurrentLoadFilePath = getCurrentLoadFilePath;
function formatKey(key, type) {
    const item = key.split('\n').map(val => val.trim());
    if (item[0].includes(type)) {
        item.shift();
    }
    if (item[item.length - 1].includes(type)) {
        item.pop();
    }
    return `-----BEGIN ${type}-----\n${item.join('')}\n-----END ${type}-----`;
}
exports.formatKey = formatKey;
