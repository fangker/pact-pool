"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const generatorFuncPrototype = Object.getPrototypeOf(function* () { });
function isGeneratorFunction(fn) {
    return typeof fn === 'function' && Object.getPrototypeOf(fn) === generatorFuncPrototype;
}
exports.FunctionContextSymbol = Symbol('FunctionContextSymbol');
function run(func, context) {
    func && func(context);
}
function createContext(inst, fn, args) {
    return {
        functionName: fn.__name || fn.name,
        inst,
        args,
    };
}
function funcWrapper(point, fn) {
    let newFn;
    if (isGeneratorFunction(fn)) {
        newFn = function* (...args) {
            const context = createContext(this, fn, args);
            try {
                run(point.before, context);
                context.ret = yield fn.apply(this, context.args);
                run(point.after, context);
                return context.ret;
            }
            catch (error) {
                context.err = error;
                run(point.error, context);
                if (context.err) {
                    throw context.err;
                }
            }
        };
    }
    else {
        // 非原生支持async的情况下没有有效方法判断async函数
        newFn = function (...args) {
            const context = createContext(this, fn, args);
            try {
                run(point.before, context);
                context.ret = fn.apply(this, context.args);
                if (context.ret instanceof Promise) {
                    context.ret = context.ret.then((ret) => {
                        context.ret = ret;
                        run(point.after, context);
                        return context.ret;
                    });
                    if (point.error) {
                        context.ret = context.ret
                            .catch(error => {
                            context.err = error;
                            run(point.error, context);
                            if (context.err) {
                                throw context.err;
                            }
                        });
                    }
                    Object.defineProperty(context.ret, exports.FunctionContextSymbol, {
                        enumerable: false,
                        configurable: true,
                        value: context,
                    });
                    return context.ret;
                }
                else {
                    run(point.after, context);
                    return context.ret;
                }
            }
            catch (error) {
                context.err = error;
                run(point.error, context);
                if (context.err) {
                    throw context.err;
                }
            }
        };
    }
    newFn.__name = fn.__name || fn.name;
    return newFn;
}
exports.funcWrapper = funcWrapper;
function aspect(point = {}) {
    return (target, key, descriptor) => {
        let fn = funcWrapper(point, descriptor.value || target[key]);
        const value = {
            configurable: true,
            get() {
                return fn;
            },
            set(value) {
                fn = funcWrapper(point, value);
            }
        };
        Object.defineProperty(target, key, value);
        return value;
    };
}
exports.aspect = aspect;
